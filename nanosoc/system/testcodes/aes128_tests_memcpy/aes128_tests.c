#include "CMSDK_CM0.h"
#include "aes128.h"
#include <string.h>
#include "uart_stdout.h"
#include <stdio.h>
// memcopy implememtation
#define os_memcpy memcpy
#define os_memset memset
// PL230DMA implementation
#include "dma_pl230_driver.h"


static volatile dma_pl230_channel_data aes_ip_chain[2];
static volatile dma_pl230_channel_data aes_op_chain[2];

// associate DMA channel numbers
#define DMA_CHAN_AES128_IP (0)
#define DMA_CHAN_AES128_OP (1)

volatile int dma_done_irq_occurred;
volatile int dma_done_irq_expected;
volatile int dma_error_irq_occurred;
volatile int dma_error_irq_expected;
volatile int aes_key_irq_occurred;
volatile int aes_key_irq_expected;
volatile int aes_ip_irq_occurred;
volatile int aes_ip_irq_expected;
volatile int aes_op_irq_occurred;
volatile int aes_op_irq_expected;
volatile int aes_err_irq_occurred;
volatile int aes_err_irq_expected;

  uint8_t _test_key128[AES_KEY_LEN_128] = {  
    0x75, 0x46, 0x20, 0x67,
    0x6e, 0x75, 0x4b, 0x20,
    0x79, 0x6d, 0x20, 0x73,
    0x74, 0x61, 0x68, 0x54 };

  uint8_t test_key128[AES_KEY_LEN_128] = {  
    0x54, 0x68, 0x61, 0x74,
    0x73, 0x20, 0x6d, 0x79,
    0x20, 0x4b, 0x75, 0x6e,
    0x67, 0x20, 0x46, 0x75 };
	
  uint8_t buf128[AES_BLOCK_SIZE] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 };

  uint8_t _test_text128[AES_BLOCK_SIZE] = {
    0x6f, 0x77, 0x54, 0x20,
    0x65, 0x6e, 0x69, 0x4e,
    0x20, 0x65, 0x6e, 0x4f,
    0x20, 0x6f, 0x77, 0x54 };

  uint8_t test_text128[AES_BLOCK_SIZE] = {
    0x54, 0x77, 0x6f, 0x20,
    0x4f, 0x6e, 0x65, 0x20,
    0x4e, 0x69, 0x6e, 0x65,
    0x20, 0x54, 0x77, 0x6f };

  uint8_t test_exp128[AES_BLOCK_SIZE] = {
    0x29, 0xc3, 0x50, 0x5f,
    0x57, 0x14, 0x20, 0xf6,
    0x40, 0x22, 0x99, 0xb3,
    0x1a, 0x02, 0xd7, 0x3a };

// add extra block[128] with all zeros to toggle bits low
  uint8_t shift_patt[129*16] = {
 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//127
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//128
 };    

  uint8_t shift_buf1[sizeof(shift_patt)];
  uint8_t shift_buf2[sizeof(shift_patt)];


/* Note:  Hardware supports byte, half-word or word accesses
   So memcpy() can be used to load/save data
   And memset() can be used to pad out data-in to 128-bits
   mode =0 (bypass), =1 (encode) or =2 (decode)
*/
void aes128_driver_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input,
                          uint8_t *result, uint8_t mode)
{
    // Reset engine
    AES128->DRQ_MSK = 0;
    AES128->IRQ_MSK = 0;
    AES128->QUAL    = 0;
    AES128->CTRL    = AES128_CTRL_KEY_REQ_BIT | AES128_CTRL_IP_REQ_BIT | AES128_CTRL_OP_REQ_BIT | AES128_CTRL_ERR_REQ_BIT;

    // Set up parameters
    if (mode == 1)
      AES128->CTRL_SET = AES128_ENCODE_BIT; // ENCODE mode
    if (mode == 0)
      AES128->CTRL_SET = AES128_BYPASS_BIT; // BYPASS mode

    AES128->IRQ_MSK_SET = (AES128_ERR_REQ_BIT | AES128_KEY_REQ_BIT | AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    
    // Program Key
    os_memcpy((uint8_t *)AES128->KEY128, key, AES_KEY_LEN_128);
    while (!(AES128->STATUS & AES128_KEYOK_BIT))
         ;

    /* payload */
    while(nbytes) {
       uint8_t len = (nbytes > AES_BLOCK_SIZE) ? AES_BLOCK_SIZE : nbytes;            
       /* Align/pad input and load into hardware */
       os_memcpy((uint8_t *)AES128->TXTIP128, input, len);
       //patch up any zero-padding
       if (len < AES_BLOCK_SIZE)
           os_memset((uint8_t *)&(AES128->TXTIP128[len]), 0, AES_BLOCK_SIZE-len);
       /* Auto-started! - no need for manual start */
       /* Poll until completed */
       while (!(AES128->STATUS & AES128_VALID_BIT))
         ;
       os_memcpy(result, (uint8_t *)AES128->TXTOP128, AES_BLOCK_SIZE);
       /* Accounting */
       input   += len;
       result  += len;
       nbytes -= len;
       AES128->IRQ_MSK_SET = (AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    }
    AES128->CTRL    = 0;
}

// wrapper functions

void aes128_bypass_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_driver_memcpy(key, nbytes, input, result, 0); }

void aes128_encrypt_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_driver_memcpy(key, nbytes, input, result, 1); }

void aes128_decrypt_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_driver_memcpy(key, nbytes, input, result, 2); }


int aes128_buffer_verify(uint32_t buflen, uint8_t *buf_A, uint8_t *buf_B)
{
    int i, j, fail = 0;
        for (i=0 ; i < buflen; i++) {
            if (buf_A[i] != buf_B[i]){
                fail = 1;
                break;
            }
        }
        if (fail) {
            j=i; // print offending block
            for (i=(j - (j%16)) ; i < (j-(j%16)+16); i++) {
               if (i%16==0)
                   printf(" //%03d\n", (i>>4));
               printf("0x%02x,", buf_A[i]);
           }
        }
        if (fail){
            i=j;
            printf("Verify compare FAIL\n      EXPECTED_RESULT[%2d]= 0x%02x, ACTUAL_RESULT= 0x%02x \n",i, buf_B[i], buf_A[i]);
            return(-1);
        }
        return(0);
}

void aes128_driver_aligned_dma32(uint8_t *key, uint32_t nbytes, uint8_t *input,
                                 uint8_t *result, uint8_t mode)
{
    int c;
    // Reset engine
    AES128->DRQ_MSK = 0;
    AES128->IRQ_MSK = 0;
    AES128->QUAL    = 0;
    AES128->CTRL    = AES128_CTRL_KEY_REQ_BIT | AES128_CTRL_IP_REQ_BIT | AES128_CTRL_OP_REQ_BIT;

    // Set up parameters
    if (mode == 1)
      AES128->CTRL_SET = AES128_ENCODE_BIT; // ENCODE mode
    if (mode == 0)
      AES128->CTRL_SET = AES128_BYPASS_BIT; // BYPASS mode
    
    dma_pl230_data_struct_init(); // initialize
    
    // program DMA transfers in multiples of 4 words (nbytes scaled >>2 for words)
    aes_ip_chain[0].SrcEndPointer = DMA_PL230_PTR_END(key,PL230_XFER_W,4);
    aes_ip_chain[0].DstEndPointer = DMA_PL230_PTR_END(&(AES128->KEY128[AES128_BUF_SIZE-16]),PL230_XFER_W,4);
    aes_ip_chain[0].Control = DMA_PL230_CTRL(PL230_CTRL_CYCLE_DEV_CHAIN_ALT,PL230_XFER_W,4,PL230_CTRL_RPWR_4);

    aes_ip_chain[1].SrcEndPointer = DMA_PL230_PTR_END(input,PL230_XFER_W,(nbytes>>2));
    aes_ip_chain[1].DstEndPointer = DMA_PL230_PTR_END(&(AES128->TXTIP128[AES128_BUF_SIZE-nbytes]),PL230_XFER_W,(nbytes>>2));
    aes_ip_chain[1].Control = DMA_PL230_CTRL(PL230_CTRL_CYCLE_BASIC,PL230_XFER_W,(nbytes>>2),PL230_CTRL_RPWR_4);

    c=DMA_CHAN_AES128_IP;
    dma_pl230_table->Primary[c].SrcEndPointer  = DMA_PL230_PTR_END(&(aes_ip_chain[0].SrcEndPointer), PL230_XFER_W,(2*4));
    dma_pl230_table->Primary[c].DstEndPointer  = DMA_PL230_PTR_END(&(dma_pl230_table->Alternate[c]), PL230_XFER_W,(1*4));
    dma_pl230_table->Primary[c].Control= DMA_PL230_CTRL_DSTFIX(PL230_CTRL_CYCLE_DEV_CHAIN_PRI,PL230_XFER_W,(2*4),PL230_CTRL_RPWR_4);

    aes_op_chain[0].SrcEndPointer = DMA_PL230_PTR_END(&(AES128->TXTOP128[AES128_BUF_SIZE-nbytes]),PL230_XFER_W,(nbytes>>2));
    aes_op_chain[0].DstEndPointer = DMA_PL230_PTR_END(result,PL230_XFER_W,(nbytes>>2));
    aes_op_chain[0].Control = DMA_PL230_CTRL(PL230_CTRL_CYCLE_BASIC,PL230_XFER_W,(nbytes>>2),PL230_CTRL_RPWR_4);

    c=DMA_CHAN_AES128_OP;        
    dma_pl230_table->Primary[c].SrcEndPointer  = DMA_PL230_PTR_END(&(aes_op_chain[0].SrcEndPointer), PL230_XFER_W,(1*4));
    dma_pl230_table->Primary[c].DstEndPointer  = DMA_PL230_PTR_END(&(dma_pl230_table->Alternate[c]), PL230_XFER_W,(1*4));
    dma_pl230_table->Primary[c].Control= DMA_PL230_CTRL_DSTFIX(PL230_CTRL_CYCLE_DEV_CHAIN_PRI,PL230_XFER_W,(1*4),PL230_CTRL_RPWR_4);
 
    // enable DMA controller channels
    dma_pl230_init((1<<DMA_CHAN_AES128_OP) | (1<<DMA_CHAN_AES128_IP)); // two active

    // and enable DMA requests
    AES128->DRQ_MSK_SET = (AES128_KEY_REQ_BIT | AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    AES128->IRQ_MSK_SET = (AES128_ERR_REQ_BIT | AES128_KEY_REQ_BIT | AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    // test to ensure output DMA has started                            
    while (!(dma_pl230_channel_active((1<<DMA_CHAN_AES128_OP))))
      ;
    while (dma_pl230_channel_active((1<<DMA_CHAN_AES128_OP)))
      ;
    while (dma_pl230_channel_active((1<<DMA_CHAN_AES128_OP)))
      ;
    AES128->DRQ_MSK = 0;
    AES128->IRQ_MSK = 0;
    DMA_PL230_DMAC->DMA_CFG = 0; /* Disable DMA controller for initialization */
    dma_pl230_init(0); // none active
    return;
}

void aes128_driver_dma8(uint8_t *key, uint32_t nbytes, uint8_t *input,
                          uint8_t *result, uint8_t mode)
{
    int c;
    // Reset engine
    AES128->DRQ_MSK = 0;
    AES128->IRQ_MSK = 0;
    AES128->QUAL    = 0;
    AES128->CTRL    = AES128_CTRL_KEY_REQ_BIT | AES128_CTRL_IP_REQ_BIT | AES128_CTRL_OP_REQ_BIT;

    // Set up parameters
    if (mode == 1)
      AES128->CTRL_SET = AES128_ENCODE_BIT; // ENCODE mode
    if (mode == 0)
      AES128->CTRL_SET = AES128_BYPASS_BIT; // BYPASS mode
    
    dma_pl230_data_struct_init(); // initialize
    
    // program DMA transfers in multiples of 16 bytes
    aes_ip_chain[0].SrcEndPointer = DMA_PL230_PTR_END(key,PL230_XFER_B,16);
    aes_ip_chain[0].DstEndPointer = DMA_PL230_PTR_END(&(AES128->KEY128[AES128_BUF_SIZE-16]),PL230_XFER_B,16);
    aes_ip_chain[0].Control = DMA_PL230_CTRL(PL230_CTRL_CYCLE_DEV_CHAIN_ALT,PL230_XFER_B,16,PL230_CTRL_RPWR_16);

    aes_ip_chain[1].SrcEndPointer = DMA_PL230_PTR_END(input,PL230_XFER_B,(nbytes));
    aes_ip_chain[1].DstEndPointer = DMA_PL230_PTR_END(&(AES128->TXTIP128[AES128_BUF_SIZE-nbytes]),PL230_XFER_B,(nbytes));
    aes_ip_chain[1].Control = DMA_PL230_CTRL(PL230_CTRL_CYCLE_BASIC,PL230_XFER_B,(nbytes),PL230_CTRL_RPWR_16);

    c=DMA_CHAN_AES128_IP;
    dma_pl230_table->Primary[c].SrcEndPointer  = DMA_PL230_PTR_END(&(aes_ip_chain[0].SrcEndPointer), PL230_XFER_W, (2*4));
    dma_pl230_table->Primary[c].DstEndPointer  = DMA_PL230_PTR_END(&(dma_pl230_table->Alternate[c]), PL230_XFER_W, (1*4));
    dma_pl230_table->Primary[c].Control= DMA_PL230_CTRL_DSTFIX(PL230_CTRL_CYCLE_DEV_CHAIN_PRI,PL230_XFER_W,(2*4),PL230_CTRL_RPWR_4);

    aes_op_chain[0].SrcEndPointer = DMA_PL230_PTR_END(&(AES128->TXTOP128[AES128_BUF_SIZE-nbytes]),PL230_XFER_B,(nbytes));
    aes_op_chain[0].DstEndPointer = DMA_PL230_PTR_END(result,PL230_XFER_B,(nbytes));
    aes_op_chain[0].Control = DMA_PL230_CTRL(PL230_CTRL_CYCLE_BASIC,PL230_XFER_B,(nbytes),PL230_CTRL_RPWR_16);

    c=DMA_CHAN_AES128_OP;        
    dma_pl230_table->Primary[c].SrcEndPointer  = DMA_PL230_PTR_END(&(aes_op_chain[0].SrcEndPointer), PL230_XFER_W,(1*4));
    dma_pl230_table->Primary[c].DstEndPointer  = DMA_PL230_PTR_END(&(dma_pl230_table->Alternate[c]), PL230_XFER_W,(1*4));
    dma_pl230_table->Primary[c].Control= DMA_PL230_CTRL_DSTFIX(PL230_CTRL_CYCLE_DEV_CHAIN_PRI,PL230_XFER_W,(1*4),PL230_CTRL_RPWR_4);
 
    // enable DMA controller channels
    dma_pl230_init((1<<DMA_CHAN_AES128_OP) | (1<<DMA_CHAN_AES128_IP)); // two active

    // and enable DMA requests
    AES128->DRQ_MSK_SET = (AES128_KEY_REQ_BIT | AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    AES128->IRQ_MSK_SET = (AES128_ERR_REQ_BIT | AES128_KEY_REQ_BIT | AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    // test to ensure output DMA has started                            
    while (!(dma_pl230_channel_active(1<<DMA_CHAN_AES128_OP)))
      ;
    while (dma_pl230_channel_active(1<<DMA_CHAN_AES128_OP))
      ;
    while (dma_pl230_channel_active(1<<DMA_CHAN_AES128_OP))
      ;
    AES128->DRQ_MSK = 0;
    AES128->IRQ_MSK = 0;
    DMA_PL230_DMAC->DMA_CFG = 0; /* Disable DMA controller for initialization */
    dma_pl230_init(0); // none active
    return;
}

// wrapper functions

void aes128_alignchk_block_dma(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result, uint8_t mode)
       { uint32_t dma_max = DMA_PL230_MAX_XFERS; // default to 1 K bytes
         if (((((long)key) & 3)==0) && ((((long)input) & 3)==0) && ((((long)result) & 3)==0)) dma_max=(DMA_PL230_MAX_XFERS<<2);
         while (nbytes >dma_max) {
            if (dma_max == DMA_PL230_MAX_XFERS) // 1K bytes DMA
              aes128_driver_dma8(key, dma_max, input, result, mode);
            else // 1K words DMA
              aes128_driver_aligned_dma32(key, dma_max, input, result, mode);
           nbytes -= dma_max; input  += dma_max; result += dma_max;
         }
         if (dma_max == DMA_PL230_MAX_XFERS) // up to 1K bytes remaining
           aes128_driver_dma8(key, nbytes, input, result, mode);
         else // up to 1K words remaining
           aes128_driver_aligned_dma32(key, nbytes, input, result, mode);
       }

void aes128_bypass_dma(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result) 
       { aes128_alignchk_block_dma (key, nbytes, input, result, 0); }

void aes128_encrypt_dma(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_alignchk_block_dma (key, nbytes, input, result, 1); }

void aes128_decrypt_dma(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_alignchk_block_dma (key, nbytes, input, result, 2); }


int main(void) {
	char rx_char [256] = "SoCLabs AES128v1"; // init to 0
	unsigned char id_string [16] = {0};
	int  i, fail=0;
        unsigned char * p;
        
		UartStdOutInit();
		printf("%s\n",rx_char);
		printf("AES128 test program\n");
		printf("  AES128 ID: ");
 	        // iterate over 3 32-bit fields
                p = (unsigned char *)AES128->CORE_NAME;
	        for (i = 0; i < 12; i++) {
                  id_string[i^3]=*p; // fix byte ordering per word
                  p+=1;
                  }
                id_string[12] = 0; 
		printf("%s\n",id_string);

                aes_key_irq_occurred = 0;
                aes_key_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP0_IRQn);
                NVIC_EnableIRQ(EXP0_IRQn);
                aes_ip_irq_occurred = 0;
                aes_ip_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP1_IRQn);
                NVIC_EnableIRQ(EXP1_IRQn);
                aes_op_irq_occurred = 0;
                aes_op_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP2_IRQn);
                NVIC_EnableIRQ(EXP2_IRQn);
                aes_err_irq_occurred = 0;
                aes_err_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP3_IRQn);
                NVIC_EnableIRQ(EXP3_IRQn);

		printf("AES128 SW (memcpy) tests...\n");
 		printf("  AES128 reference pattern test\n");

 		printf("    AES128 input/output bypass test\n");
                aes128_bypass_memcpy(test_key128, sizeof(test_text128), test_text128, buf128);
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_text128);

               if (aes_key_irq_occurred != 1){ fail++;
                   printf("    ++ AES key request IRQ count = %d\n", aes_key_irq_occurred); }
               if (aes_ip_irq_occurred != 2){ fail++;
                   printf("    ++ AES inp request missing: IRQ count = %d\n", aes_ip_irq_occurred); }
               if (aes_op_irq_occurred != 1){ fail++;
                   printf("    ++ AES out request missing: IRQ count = %d\n", aes_op_irq_occurred); }
               if (aes_err_irq_occurred != 0){ fail++;
                   printf("    ++ AES err request missing: IRQ count = %d\n", aes_err_irq_occurred); }

		printf("    AES128 encrypt test\n");
                aes128_encrypt_memcpy(test_key128, sizeof(test_text128), test_text128, buf128); 
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_exp128);

 		printf("    AES128 decrypt test\n");
                aes128_decrypt_memcpy(test_key128, sizeof(buf128), buf128, buf128);
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_text128);

                aes_key_irq_occurred = 0;
                aes_ip_irq_occurred = 0;
                aes_op_irq_occurred = 0;
                aes_err_irq_occurred = 0;

 		printf("  AES128 logic toggle test\n");
		printf("    AES128 input/output pattern test\n");
                aes128_bypass_memcpy(test_key128, sizeof(shift_patt), shift_patt, shift_buf1); 
                fail += aes128_buffer_verify(sizeof(shift_patt), shift_buf1, shift_patt);

               if (aes_key_irq_occurred != 1){ fail++;
                   printf("    ++ AES key request IRQ count = %d\n", aes_key_irq_occurred); }
               if (aes_ip_irq_occurred != (129+1)){ fail++;
                   printf("    ++ AES inp request missing: IRQ count = %d\n", aes_ip_irq_occurred); }
               if (aes_op_irq_occurred != 129){ fail++;
                   printf("    ++ AES out request missing: IRQ count = %d\n", aes_op_irq_occurred); }
               if (aes_err_irq_occurred != 0){ fail++;
                   printf("    ++ AES err request missing: IRQ count = %d\n", aes_err_irq_occurred); }

		printf("    AES128 pattern encrypt test\n");
                aes128_encrypt_memcpy(test_key128, sizeof(shift_patt), shift_patt, shift_buf1); 
 		printf("    AES128 pattern decrypt test\n");
                aes128_decrypt_memcpy(test_key128, sizeof(shift_patt), shift_buf1, shift_buf2); 
                fail += aes128_buffer_verify(sizeof(shift_patt), shift_buf2, shift_patt);

		printf("AES128 DMA tests...\n");

                aes_key_irq_occurred = 0;
                aes_ip_irq_occurred = 0;
                aes_op_irq_occurred = 0;
                aes_err_irq_occurred = 0;
                dma_error_irq_expected = 0;
                dma_error_irq_occurred = 0;
                dma_done_irq_expected = 1;
                dma_done_irq_occurred = 0;
                NVIC_ClearPendingIRQ(DMA_IRQn);
                NVIC_EnableIRQ(DMA_IRQn);

 		printf("  AES128 dma input/output bypass test\n");
                aes128_bypass_dma(test_key128, sizeof(test_text128), test_text128, buf128);
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_text128);

               if (dma_done_irq_occurred < 2){
                  puts ("ERROR: DMA err IRQ missing");
                  fail++;
                 } else
                   printf("    ++ DMA_DONE IRQ count = %d\n", dma_done_irq_occurred);

		printf("  AES128 dma encrypt test\n");
                aes128_encrypt_dma(test_key128, sizeof(test_text128), test_text128, buf128); 
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_exp128);

 		printf("  AES128 dma decrypt test\n");
                aes128_decrypt_dma(test_key128, sizeof(buf128), buf128, buf128);
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_text128);

               if (dma_done_irq_occurred < 6){
                  puts ("ERROR: DMA err IRQ missing");
                  fail++;
                 } else
                   printf("    ++ DMA_DONE IRQ count = %d\n", dma_done_irq_occurred);

		printf("  AES128 dma unaligned pattern test\n");
                aes128_bypass_dma(test_key128,(16*63), shift_patt, shift_buf1+3); 
                fail += aes128_buffer_verify((16*63), shift_buf1+3, shift_patt);

		printf("  AES128 dma input/output pattern test\n");
                aes128_bypass_dma(test_key128, sizeof(shift_patt), shift_patt, shift_buf1); 
                fail += aes128_buffer_verify(sizeof(shift_patt), shift_buf1, shift_patt);
		printf("  AES128 dma pattern encrypt test\n");
                aes128_encrypt_dma(test_key128, sizeof(shift_patt), shift_patt, shift_buf1); 
 		printf("  AES128 dma pattern decrypt test\n");
                aes128_decrypt_dma(test_key128, sizeof(shift_patt), shift_buf1, shift_buf2); 
                fail += aes128_buffer_verify(sizeof(shift_patt), shift_buf2, shift_patt);

               if (dma_done_irq_occurred < (2*7)){
                  puts ("ERROR: DMA err IRQ missing");
                  fail++;
                 } else
                   printf("    ++ DMA_DONE IRQ count = %d\n", dma_done_irq_occurred);

               // check IRQ masked by DRQs - except when Iinput buffer empty after DMA done
               if (aes_key_irq_occurred != 0){ fail++;
                   printf("    ++ AES key request IRQ count = %d\n", aes_key_irq_occurred); }
               if (aes_ip_irq_occurred != 7){ fail++;
                   printf("    ++ AES inp request missing: IRQ count = %d\n", aes_ip_irq_occurred); }
               if (aes_op_irq_occurred != 0){ fail++;
                   printf("    ++ AES out request missing: IRQ count = %d\n", aes_op_irq_occurred); }
               if (aes_err_irq_occurred != 0){ fail++;
                   printf("    ++ AES err request missing: IRQ count = %d\n", aes_err_irq_occurred); }

                NVIC_DisableIRQ(DMA_IRQn);
                NVIC_DisableIRQ(EXP0_IRQn);
                NVIC_DisableIRQ(EXP1_IRQn);
                NVIC_DisableIRQ(EXP2_IRQn);
                NVIC_DisableIRQ(EXP3_IRQn);

  		printf ("Data retrieved from the AES is: %s\n", id_string);
		printf ("Data expected from the AES is: %s\n", rx_char);
		if (fail >0)
		  printf("** AES TESTS FAILED (%d)  **\n", fail);
                else
		  printf("** AES TEST PASSED **\n");
		// End simulation


  		UartEndSimulation();

  	return 0;

}
	
/* --------------------------------------------------------------- */
/*  Interrupt handlers                                         */
/* --------------------------------------------------------------- */

void DMA_Handler(void)
{
if ((DMA_PL230_DMAC->ERR_CLR & 1) != 0)  {
  /* DMA interrupt is caused by DMA error */
  dma_error_irq_occurred ++;
  DMA_PL230_DMAC->ERR_CLR = 1; /* Clear dma_err */
  if (dma_error_irq_expected==0) {
    puts ("ERROR : Unexpected DMA error interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
  }
else {
  // DMA interrupt is caused by DMA done
  dma_done_irq_occurred ++;
  if (dma_done_irq_expected==0) {
    puts ("ERROR : Unexpected DMA done interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
  }
}

void EXP0_Handler(void)
{
  // AES128 interrupt is caused by Key buffer empty IRQ
  aes_key_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_KEY_REQ_BIT;
  if (aes_key_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Key buffer empty request interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

void EXP1_Handler(void)
{
  // AES128 interrupt is caused by Input buffer empty IRQ
  aes_ip_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_IP_REQ_BIT;
  if (aes_ip_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Input buffer empty reqest interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

void EXP2_Handler(void)
{
  // AES128 interrupt is caused by Output buffer full IRQ
  aes_op_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_OP_REQ_BIT;
  if (aes_op_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Output buffer full reqest interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

void EXP3_Handler(void)
{
  // AES128 interrupt is caused by Error IRQ
  aes_err_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_ERR_REQ_BIT;
  if (aes_err_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Error interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

