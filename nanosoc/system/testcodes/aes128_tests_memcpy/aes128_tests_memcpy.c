#include "CMSDK_CM0.h"
#include "aes128.h"
#include <string.h>
#include "uart_stdout.h"
#include <stdio.h>
// memcopy implememtation
#define os_memcpy memcpy
#define os_memset memset

volatile int aes_key_irq_occurred;
volatile int aes_key_irq_expected;
volatile int aes_ip_irq_occurred;
volatile int aes_ip_irq_expected;
volatile int aes_op_irq_occurred;
volatile int aes_op_irq_expected;
volatile int aes_err_irq_occurred;
volatile int aes_err_irq_expected;

  uint8_t _test_key128[AES_KEY_LEN_128] = {  
    0x75, 0x46, 0x20, 0x67,
    0x6e, 0x75, 0x4b, 0x20,
    0x79, 0x6d, 0x20, 0x73,
    0x74, 0x61, 0x68, 0x54 };

  uint8_t test_key128[AES_KEY_LEN_128] = {  
    0x54, 0x68, 0x61, 0x74,
    0x73, 0x20, 0x6d, 0x79,
    0x20, 0x4b, 0x75, 0x6e,
    0x67, 0x20, 0x46, 0x75 };
	
  uint8_t buf128[AES_BLOCK_SIZE] = {
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00 };

  uint8_t _test_text128[AES_BLOCK_SIZE] = {
    0x6f, 0x77, 0x54, 0x20,
    0x65, 0x6e, 0x69, 0x4e,
    0x20, 0x65, 0x6e, 0x4f,
    0x20, 0x6f, 0x77, 0x54 };

  uint8_t test_text128[AES_BLOCK_SIZE] = {
    0x54, 0x77, 0x6f, 0x20,
    0x4f, 0x6e, 0x65, 0x20,
    0x4e, 0x69, 0x6e, 0x65,
    0x20, 0x54, 0x77, 0x6f };

  uint8_t test_exp128[AES_BLOCK_SIZE] = {
    0x29, 0xc3, 0x50, 0x5f,
    0x57, 0x14, 0x20, 0xf6,
    0x40, 0x22, 0x99, 0xb3,
    0x1a, 0x02, 0xd7, 0x3a };

// add extra block[128] with all zeros to toggle bits low
  uint8_t shift_patt[129*16] = {
 0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x00,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0x80,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xc0,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xe0,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf0,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xf8,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfc,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xfe,
 0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,0xff,//127
 0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,//128
 };    

  uint8_t shift_buf1[sizeof(shift_patt)];
  uint8_t shift_buf2[sizeof(shift_patt)];


/* Note:  Hardware supports byte, half-word or word accesses
   So memcpy() can be used to load/save data
   And memset() can be used to pad out data-in to 128-bits
   mode =0 (bypass), =1 (encode) or =2 (decode)
*/
void aes128_driver_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input,
                          uint8_t *result, uint8_t mode)
{
    // Reset engine
    AES128->DRQ_MSK = 0;
    AES128->IRQ_MSK = 0;
    AES128->QUAL    = 0;
    AES128->CTRL    = AES128_CTRL_KEY_REQ_BIT | AES128_CTRL_IP_REQ_BIT | AES128_CTRL_OP_REQ_BIT | AES128_CTRL_ERR_REQ_BIT;

    // Set up parameters
    if (mode == 1)
      AES128->CTRL_SET = AES128_ENCODE_BIT; // ENCODE mode
    if (mode == 0)
      AES128->CTRL_SET = AES128_BYPASS_BIT; // BYPASS mode

    AES128->IRQ_MSK_SET = (AES128_ERR_REQ_BIT | AES128_KEY_REQ_BIT | AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    
    // Program Key
    os_memcpy((uint8_t *)AES128->KEY128, key, AES_KEY_LEN_128);
    while (!(AES128->STATUS & AES128_KEYOK_BIT))
         ;

    /* payload */
    while(nbytes) {
       uint8_t len = (nbytes > AES_BLOCK_SIZE) ? AES_BLOCK_SIZE : nbytes;            
       /* Align/pad input and load into hardware */
       os_memcpy((uint8_t *)AES128->TXTIP128, input, len);
       //patch up any zero-padding
       if (len < AES_BLOCK_SIZE)
           os_memset((uint8_t *)&(AES128->TXTIP128[len]), 0, AES_BLOCK_SIZE-len);
       /* Auto-started! - no need for manual start */
       /* Poll until completed */
       while (!(AES128->STATUS & AES128_VALID_BIT))
         ;
       os_memcpy(result, (uint8_t *)AES128->TXTOP128, AES_BLOCK_SIZE);
       /* Accounting */
       input   += len;
       result  += len;
       nbytes -= len;
       AES128->IRQ_MSK_SET = (AES128_IP_REQ_BIT | AES128_OP_REQ_BIT);
    }
    AES128->CTRL    = 0;
}

// wrapper functions

void aes128_bypass_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_driver_memcpy(key, nbytes, input, result, 0); }

void aes128_encrypt_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_driver_memcpy(key, nbytes, input, result, 1); }

void aes128_decrypt_memcpy(uint8_t *key, uint32_t nbytes, uint8_t *input, uint8_t *result)
       { aes128_driver_memcpy(key, nbytes, input, result, 2); }


int aes128_buffer_verify(uint32_t buflen, uint8_t *buf_A, uint8_t *buf_B)
{
    int i, j, fail = 0;
        for (i=0 ; i < buflen; i++) {
            if (buf_A[i] != buf_B[i]){
                fail = 1;
                break;
            }
        }
        if (fail) {
            j=i; // print offending block
            for (i=(j - (j%16)) ; i < (j-(j%16)+16); i++) {
               if (i%16==0)
                   printf(" //%03d\n", (i>>4));
               printf("0x%02x,", buf_A[i]);
           }
        }
        if (fail){
            i=j;
            printf("Verify compare FAIL\n      EXPECTED_RESULT[%2d]= 0x%02x, ACTUAL_RESULT= 0x%02x \n",i, buf_B[i], buf_A[i]);
            return(-1);
        }
        return(0);
}


int main(void) {
	char rx_char [256] = "SoCLabs AES128v1"; // init to 0
	unsigned char id_string [16] = {0};
	int  i, fail=0;
        unsigned char * p;
        
		UartStdOutInit();
		printf("%s\n",rx_char);
		printf("AES128 test program\n");
		printf("  AES128 ID: ");
 	        // iterate over 3 32-bit fields
                p = (unsigned char *)AES128->CORE_NAME;
	        for (i = 0; i < 12; i++) {
                  id_string[i^3]=*p; // fix byte ordering per word
                  p+=1;
                  }
                id_string[12] = 0; 
		printf("%s\n",id_string);

                aes_key_irq_occurred = 0;
                aes_key_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP0_IRQn);
                NVIC_EnableIRQ(EXP0_IRQn);
                aes_ip_irq_occurred = 0;
                aes_ip_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP1_IRQn);
                NVIC_EnableIRQ(EXP1_IRQn);
                aes_op_irq_occurred = 0;
                aes_op_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP2_IRQn);
                NVIC_EnableIRQ(EXP2_IRQn);
                aes_err_irq_occurred = 0;
                aes_err_irq_expected = 1;
                NVIC_ClearPendingIRQ(EXP3_IRQn);
                NVIC_EnableIRQ(EXP3_IRQn);

		printf("AES128 SW (memcpy) tests...\n");
 		printf("  AES128 reference pattern test\n");

 		printf("    AES128 input/output bypass test\n");
                aes128_bypass_memcpy(test_key128, sizeof(test_text128), test_text128, buf128);
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_text128);

               if (aes_key_irq_occurred != 1){ fail++;
                   printf("    ++ AES key request IRQ count = %d\n", aes_key_irq_occurred); }
               if (aes_ip_irq_occurred != 2){ fail++;
                   printf("    ++ AES inp request missing: IRQ count = %d\n", aes_ip_irq_occurred); }
               if (aes_op_irq_occurred != 1){ fail++;
                   printf("    ++ AES out request missing: IRQ count = %d\n", aes_op_irq_occurred); }
               if (aes_err_irq_occurred != 0){ fail++;
                   printf("    ++ AES err request missing: IRQ count = %d\n", aes_err_irq_occurred); }

		printf("    AES128 encrypt test\n");
                aes128_encrypt_memcpy(test_key128, sizeof(test_text128), test_text128, buf128); 
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_exp128);

 		printf("    AES128 decrypt test\n");
                aes128_decrypt_memcpy(test_key128, sizeof(buf128), buf128, buf128);
                fail += aes128_buffer_verify(AES_BLOCK_SIZE, buf128, test_text128);

                aes_key_irq_occurred = 0;
                aes_ip_irq_occurred = 0;
                aes_op_irq_occurred = 0;
                aes_err_irq_occurred = 0;

 		printf("  AES128 logic toggle test\n");
		printf("    AES128 input/output pattern test\n");
                aes128_bypass_memcpy(test_key128, sizeof(shift_patt), shift_patt, shift_buf1); 
                fail += aes128_buffer_verify(sizeof(shift_patt), shift_buf1, shift_patt);

               if (aes_key_irq_occurred != 1){ fail++;
                   printf("    ++ AES key request IRQ count = %d\n", aes_key_irq_occurred); }
               if (aes_ip_irq_occurred != (129+1)){ fail++;
                   printf("    ++ AES inp request missing: IRQ count = %d\n", aes_ip_irq_occurred); }
               if (aes_op_irq_occurred != 129){ fail++;
                   printf("    ++ AES out request missing: IRQ count = %d\n", aes_op_irq_occurred); }
               if (aes_err_irq_occurred != 0){ fail++;
                   printf("    ++ AES err request missing: IRQ count = %d\n", aes_err_irq_occurred); }

		printf("    AES128 pattern encrypt test\n");
                aes128_encrypt_memcpy(test_key128, sizeof(shift_patt), shift_patt, shift_buf1); 
 		printf("    AES128 pattern decrypt test\n");
                aes128_decrypt_memcpy(test_key128, sizeof(shift_patt), shift_buf1, shift_buf2); 
                fail += aes128_buffer_verify(sizeof(shift_patt), shift_buf2, shift_patt);

                NVIC_DisableIRQ(EXP0_IRQn);
                NVIC_DisableIRQ(EXP1_IRQn);
                NVIC_DisableIRQ(EXP2_IRQn);
                NVIC_DisableIRQ(EXP3_IRQn);

  		printf ("Data retrieved from the AES is: %s\n", id_string);
		printf ("Data expected from the AES is: %s\n", rx_char);
		if (fail >0)
		  printf("** AES TESTS FAILED (%d)  **\n", fail);
                else
		  printf("** AES TEST PASSED **\n");
		// End simulation


  		UartEndSimulation();

  	return 0;

}
	
/* --------------------------------------------------------------- */
/*  Interrupt handlers                                         */
/* --------------------------------------------------------------- */

void EXP0_Handler(void)
{
  // AES128 interrupt is caused by Key buffer empty IRQ
  aes_key_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_KEY_REQ_BIT;
  if (aes_key_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Key buffer empty request interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

void EXP1_Handler(void)
{
  // AES128 interrupt is caused by Input buffer empty IRQ
  aes_ip_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_IP_REQ_BIT;
  if (aes_ip_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Input buffer empty reqest interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

void EXP2_Handler(void)
{
  // AES128 interrupt is caused by Output buffer full IRQ
  aes_op_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_OP_REQ_BIT;
  if (aes_op_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Output buffer full reqest interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

void EXP3_Handler(void)
{
  // AES128 interrupt is caused by Error IRQ
  aes_err_irq_occurred ++;
  AES128->IRQ_MSK_CLR = AES128_ERR_REQ_BIT;
  if (aes_err_irq_expected==0) {
    puts ("ERROR : Unexpected AES128 Error interrupt occurred.\n");
    UartEndSimulation();
    while (1);
    }
}

